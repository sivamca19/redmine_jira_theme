<%
  # Only enable inline edit if jira theme is enabled and user is logged in
  jira_settings = Setting.plugin_redmine_jira_theme || {}
  theme_enabled = jira_settings['enabled'] == '1'
  user_logged_in = User.current.logged?
%>

<% if theme_enabled && user_logged_in %>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    function makeInlineEditable(selector, field, optionsUrl, updateUrl, issueId) {
      const el = document.querySelector(selector);
      if (!el) return;

      el.style.cursor = "pointer";

      el.addEventListener("click", function () {
        if (el.querySelector("select")) return; // already editing

        const currentValue = el.innerText.trim();
        const select = document.createElement("select");

        // fetch available options from backend using API key authentication
        const apiKey = "<%= User.current.api_key if User.current.logged? %>";
        if (!apiKey) {
          console.error("API key not found - user not logged in");
          return;
        }

        fetch(`${optionsUrl}?field=${field}&issue_id=${issueId}&key=${apiKey}`, {
          method: "GET",
          headers: {
            "Accept": "application/json",
            "X-Requested-With": "XMLHttpRequest"
          }
        })
          .then(res => {
            if (!res.ok) {
              console.error(`Options fetch failed: ${res.status} ${res.statusText}`);
              throw new Error(`HTTP ${res.status}: ${res.statusText}`);
            }
            return res.json();
          })
          .then(options => {
            options.forEach(opt => {
              const option = document.createElement("option");
              option.value = opt.id;
              option.text = opt.name;
              if (opt.name === currentValue) option.selected = true;
              select.appendChild(option);
            });

            el.innerHTML = "";
            el.appendChild(select);
            select.focus();

            select.addEventListener("change", function () {
              if (!apiKey) {
                console.error("API key not found for update");
                el.innerText = currentValue;
                return;
              }

              fetch(`${updateUrl}?key=${apiKey}`, {
                method: "PATCH",
                headers: {
                  "Content-Type": "application/json",
                  "Accept": "application/json",
                  "X-Requested-With": "XMLHttpRequest"
                },
                body: JSON.stringify({ issue: { [field]: this.value } })
              })
                .then(res => {
                  if (!res.ok) {
                    console.error(`Update failed: ${res.status} ${res.statusText}`);
                    throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                  }
                  return res.json();
                })
                .then(data => {
                  console.log("Update successful:", field, data);
                  if (data.success) {
                    if (field === "assigned_to_id" && this.options[this.selectedIndex].value) {
                      // Create a link for assigned user
                      const a = document.createElement("a");
                      a.className = "user active";
                      a.href = `/users/${this.options[this.selectedIndex].value}`;
                      a.innerText = this.options[this.selectedIndex].text;
                      el.innerHTML = "";
                      el.appendChild(a);
                    } else {
                      el.innerText = data.updated_text || this.options[this.selectedIndex].text;
                    }
                  } else {
                    console.error("Update failed:", data.errors || data.error);
                    el.innerText = currentValue;
                  }
                })
                .catch((error) => {
                  console.error("Update error:", error);
                  el.innerText = currentValue; // fallback on error
                });
            });
          })
          .catch((error) => {
            console.error("Options fetch error:", error);
            el.innerText = currentValue; // fallback on error
          });
      });
    }

    // Extract issue id once
    const issueId = document.querySelector("h2.inline-block")?.textContent.match(/#(\d+)/)?.[1];
    if (!issueId) return;

    // Common inline edit fields
    makeInlineEditable(".attributes .assigned-to .value", "assigned_to_id", "/jira_theme/options.json", `/jira_theme/issues/${issueId}.json`, issueId);
    makeInlineEditable(".attributes .priority .value", "priority_id", "/jira_theme/options.json", `/jira_theme/issues/${issueId}.json`, issueId);

    // Status field (conditional, server-driven)
    <% if @issue.new_statuses_allowed_to(User.current).any? %>
      makeInlineEditable(".attributes .status .value", "status_id", "/jira_theme/options.json", `/jira_theme/issues/${issueId}.json`, issueId);
    <% else %>
      const statusValue = document.querySelector(".attributes .status .value");
      if (statusValue) {
        statusValue.style.cursor = "not-allowed";
        statusValue.style.pointerEvents = "none";
        statusValue.setAttribute("title", "You are not allowed to change the status");
      }
    <% end %>
  });
</script>
<% end %>